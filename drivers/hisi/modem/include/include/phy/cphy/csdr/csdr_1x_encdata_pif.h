/** ****************************************************************************

                    Huawei Technologies Sweden AB (C), 2001-2011

 ********************************************************************************
 * @author    Automatically generated by DAISY
 * @version
 * @date      2014-06-26
 * @file
 * @brief
 * This interface carries message units and channel control parameters from
 * 1x_Layer_2 to be encoded. It includes:
 * Input: Primitive including reference to data stream. Frequency: Once per
 * frame to be encoded.
 * @copyright Huawei Technologies Sweden AB
 *******************************************************************************/
#ifndef CSDR_1X_ENCDATA_PIF_H
#define CSDR_1X_ENCDATA_PIF_H

/*******************************************************************************
 1. Other files included
*******************************************************************************/
#include "uphy_type_define.h"
#include "csdr_1x_data_public_pif.h"

#ifdef __cplusplus
#if __cplusplus
    extern "C" {
#endif /* __cpluscplus */
#endif /* __cpluscplus */
#pragma pack(4)

/*******************************************************************************
 2. Macro definitions
*******************************************************************************/
/**
 * per segment maximum size in per segment in octet in a ACH probe, then
 * transfer into 16-bit for DSP
 * 32-bit align(88bit) = 96bit, 16-bit-occupied(96 bit) = 6*uint16
 */
#define CSDR_1X_ACH_PER_PROBE_BLK_MAX_SIZE                  ( 6 )
/**
 * per segment maximum size in per segment in 32-bit aligned in an EACH probe,
 * then transfer into 16-bit for DSP
 * 32-bit align(744bit) = 768bit, 16-bit-occupied(768 bit) = 48*uint16
 */
#define CSDR_1X_EACH_PER_PROBE_BLK_MAX_SIZE                 ( 48 )
/**
 * maximum frame size in in 32-bit aligned on R-DCCH, then transfers into
 * 16-bit for DSP
 * 32-bit align(267bit) = 288bit, 16-bit-occupied(288) = 18
 */
#define CSDR_1X_RDCCH_BLK_MAX_SIZE                          ( 18 )
/**
 * maximum frame size in in 32-bit aligned on R-FCH, then transfers into
 * 16-bit for DSP
 * 32-bit align(267bit) = 288bit, 16-bit-occupied(288 bit) = 18*uint16
 */
#define CSDR_1X_RFCH_BLK_MAX_SIZE                           ( 18 )
/**
 * maximum frame size in in 32-bit aligned on R-SCCH, then transfers into
 * 16-bit for DSP
 * 32-bit align(267bit) = 288bit, 16-bit-occupied(288) = 18
 */
#define CSDR_1X_RSCCH_BLK_MAX_SIZE                          ( 18 )
/**
 * maximum frame size in in 32-bit aligned on R-SCH, then transfers into
 * 16-bit for DSP
 * 32-bit align(6120bit) = 6144bit, 16-bit-occupied(6144) = 384
 */
#define CSDR_1X_RSCH_BLK_MAX_SIZE                           ( 384 )
#define CSDR_1X_ESTIMATE_DCCH_BIT_MASK                      ( 0x10 )
#define CSDR_1X_ESTIMATE_FCH_BIT_MASK                       ( 0x2 )
#define CSDR_1X_ESTIMATE_PILOT_BIT_MASK                     ( 0x1 )
#define CSDR_1X_ESTIMATE_SCCH_BIT_MASK                      ( 0x8 )
#define CSDR_1X_ESTIMATE_SCH_BIT_MASK                       ( 0x4 )
/**
 * MAC will write all access channel frames when providing the first frame in
 * a probe. A frame is a block. From figure 2-10. Access Attempt (Part 2) in
 * C.S0003, there are 10 frames at most on ACH.
 */
#define CSDR_1X_MAX_ACH_DATA_BLK_CNT                        ( 10 )
/**
 * MAC will write all enhanced access channel frames when providing the first
 * frame in a probe. A frame is a block. There are 18 blocks at most on EACH,
 * refer to the table blow.
 * _TABLE_bold,border\!45,90\!
 * ACC_RATEs |ACC_FRAME_DURATIONs |ACC_MAX_DURATONs |ACC_RESIDUAL_SIZEs
 * |Information bits |loop cnt\?
 * 9600  |20      |16     |768    |172    |5\?
 * 19200  |10      |16     |1536    |172    |9\?
 * 19200  |20      |16     |1536    |360    |5\?
 * 38400  |20      |16     |3072    |744    |5\?
 * 38400  |10      |16     |3072    |360    |9\?
 * 38400  |5      |16     |3072    |172    |18
 * \!frame count on EACH.
 * _TABLE_
 */
#define CSDR_1X_MAX_EACH_DATA_BLK_CNT                       ( 18 )
/**
 * It's used to calculate how many octet will be occupied in memory for a
 * segment maximum size in a ACH probe.
 */
#define CSDR_1X_ACH_PER_PROBE_BLK_MAX_MEM_OCCUPIED          ( CTTF_CSDR_1X_MEMORY_OCCUPIED(CSDR_1X_ACH_PER_PROBE_BLK_MAX_SIZE) )
/**
 * It's used to calculate how many octet will be occupied in memory for a
 * segment maximum size in a EACH probe.
 */
#define CSDR_1X_EACH_PER_PROBE_BLK_MAX_MEM_OCCUPIED         ( CTTF_CSDR_1X_MEMORY_OCCUPIED(CSDR_1X_EACH_PER_PROBE_BLK_MAX_SIZE) )
/**
 * It's used to calculate how many octet will be occupied in memory for a
 * block maximum size in a R-DCCH frame.
 */
#define CSDR_1X_RDCCH_BLK_MAX_MEM_OCCUPIED                  ( CTTF_CSDR_1X_MEMORY_OCCUPIED(CSDR_1X_RDCCH_BLK_MAX_SIZE) )
/**
 * It's used to calculate how many octet will be occupied in memory for a
 * block maximum size in a R-FCH frame.
 */
#define CSDR_1X_RFCH_BLK_MAX_MEM_OCCUPIED                   ( CTTF_CSDR_1X_MEMORY_OCCUPIED(CSDR_1X_RFCH_BLK_MAX_SIZE) )
/**
 * It's used to calculate how many octet will be occupied in memory for a
 * block maximum size in a R-SCH frame.
 */
#define CSDR_1X_RSCH_BLK_MAX_MEM_OCCUPIED                   ( CTTF_CSDR_1X_MEMORY_OCCUPIED(CSDR_1X_RSCH_BLK_MAX_SIZE) )
#define CSDR_1X_REV_MAX_BLK_NUM_PER_RING_BUFFER             ( 3 )


/*******************************************************************************
 3. Enumerations declarations
*******************************************************************************/
/** ****************************************************************************
 * Name        : CSDR_1X_ENCDATA_PIF_MSG_TYPE_ENUM_UINT16
 * Description :
 *******************************************************************************/
enum CSDR_1X_ENCDATA_PIF_MSG_TYPE_ENUM
{
    ID_CTTF_CSDR_1X_ACH_TRACE_DATA_REQ                      = 0x0000, /* _H2ASN_MsgChoice CTTF_CSDR_1X_ACH_TRACE_DATA_REQ_STRU*/ /**< @sa CTTF_CSDR_1X_ACH_TRACE_DATA_REQ_STRU */
    ID_CTTF_CSDR_1X_EACH_TRACE_DATA_REQ                     = 0x0001, /* _H2ASN_MsgChoice CTTF_CSDR_1X_EACH_TRACE_DATA_REQ_STRU*/ /**< @sa CTTF_CSDR_1X_EACH_TRACE_DATA_REQ_STRU */
    ID_CTTF_CSDR_1X_FCH_TRACE_DATA_REQ                      = 0x0002, /* _H2ASN_MsgChoice CTTF_CSDR_1X_FCH_TRACE_DATA_REQ_STRU*/ /**< @sa CTTF_CSDR_1X_FCH_TRACE_DATA_REQ_STRU */
    ID_CTTF_CSDR_1X_SCH_TRACE_DATA_REQ                      = 0x0003, /* _H2ASN_MsgChoice CTTF_CSDR_1X_SCH_TRACE_DATA_REQ_STRU*/ /**< @sa CTTF_CSDR_1X_SCH_TRACE_DATA_REQ_STRU */
    ID_CTTF_CSDR_1X_DCCH_TRACE_DATA_REQ                     = 0x0004, /* _H2ASN_MsgChoice CTTF_CSDR_1X_DCCH_TRACE_DATA_REQ_STRU*/ /**< @sa CTTF_CSDR_1X_DCCH_TRACE_DATA_REQ_STRU */
    ID_CTTF_CSDR_1X_SCCH_TRACE_DATA_REQ                     = 0x0005, /* _H2ASN_MsgChoice CTTF_CSDR_1X_SCCH_TRACE_DATA_REQ_STRU*/ /**< @sa CTTF_CSDR_1X_SCCH_TRACE_DATA_REQ_STRU */
    ID_CSDR_1X_ENCDATA_PIF_MSG_TYPE_ENUM_BUTT               = 0xFFFF
};
typedef VOS_UINT16 CSDR_1X_ENCDATA_PIF_MSG_TYPE_ENUM_UINT16;

/** ****************************************************************************
 * Name        : CSDR_1X_MUTEX_ENUM_UINT16
 * Description : It's used to indicate whether data has been written or not.
 * The purpose is avoid data is being writing, SDR begins to read data; or SDR
 * is busy on reading data, MAC goes to update data. So when @enMutexFlag is
 * data not existed, MAC can write data. And then MAC sets @enMutexFlag to
 * data existed. Till then, SDR can begin to read data. After read out data,
 * SDR sets @enMutexFlag to data not existed.
 *******************************************************************************/
enum CSDR_1X_MUTEX_ENUM
{
    CSDR_1X_MUTEX_DATA_NOT_EXISTED      = 0x0000,
    CSDR_1X_MUTEX_DATA_EXISTED          = 0x0001,
    CSDR_1X_MUTEX_BUTT                  = 0x0002
};
typedef VOS_UINT16 CSDR_1X_MUTEX_ENUM_UINT16;

/** ****************************************************************************
 * Name        : CSDR_1X_TX_CTRL_ENUM_UINT16
 * Description : It's used to indicate whether allow MAC to tx data or not.
 * CSDR_1X_ALLOW_TX: allow MAC to tx data, but MAC needs to check which
 * channel can tx data by cfg-id
 * CSDR_1X_NOT_ALLOW_TX: forbidden to tx data on any channel
 *******************************************************************************/
enum CSDR_1X_TX_CTRL_ENUM
{
    CSDR_1X_ALLOW_TX                    = 0x0000,
    CSDR_1X_NOT_ALLOW_TX                = 0x0001,
    CSDR_1X_TX_CTRL_BUTT                = 0x0002
};
typedef VOS_UINT16 CSDR_1X_TX_CTRL_ENUM_UINT16;


/*******************************************************************************
 4. Message Header declaration
*******************************************************************************/

/*******************************************************************************
 5. Message declaration
*******************************************************************************/

/*******************************************************************************
 6. STRUCT and UNION declaration
*******************************************************************************/
/** ****************************************************************************
 * Name        : CTTF_CSDR_1X_R_TCH_ADJ_GAIN_STRU
 * Description : It's used to calc the reverse channel code output power.
 * The procedure is defined in section 2.1.2.3.1.5 in 3GPP2 C.S0002-A v6.0:
 * "Physical Layer Standard for cdma2000 Spread Spectrum Systems", page 2-49,
 * line 16~30.
 * @sAttAdjGain: "Attribute_Adjustment_Gain", which is an offset relative to the
 * Reverse Pilot Channel power for each data rate, frame duration, and type of coding
 * supported by the mobile station;
 * @sNomAttAdjGain: "Nominal_Attribute_Gain", which is the nominal Reverse Fundamental Channel,
 * Reverse Supplemental Channel, or Reverse Dedicated Control Channel power relative to the
 * Reverse Pilot Channel power for each data rate listed in  Table  2.1.2.3.3.7-1  and  Table
 * 2.1.2.3.3.7-2, frame duration, and  type of  coding  supported by the mobile station.
 * @usPilotRefLvl: "Pilot_Reference_Level", which is used to define MAX_Channel,
 * i.e. Pilot_Reference_Level[Rate, Channel] = Nominal_Pilot_Reference_Level[Rate, Channel] + Pilot_Attribute_Adjustment_Gain[Rate, Channel].

 *******************************************************************************/
typedef struct
{
    VOS_INT16                           sAttAdjGain;
    VOS_INT16                           sNomAttAdjGain;
    VOS_UINT16                          usPilotRefLvl;
    VOS_UINT16                          usReserved;
}CTTF_CSDR_1X_R_TCH_ADJ_GAIN_STRU;

/** ****************************************************************************
 * Name        : CTTF_CSDR_1X_R_POWERCTRL_STRU
 * Description : It's used to estimate reverse channel power. 1x_Layer_1 will
 * use power control command and last frame size to calculate the estimated
 * power consuming, and write them into structure defined below. 1x_MAC_Tx
 * will read estimated power consuming to analysis how to schedule data from
 * upper service to match the power.
 * The procedure is defined in section 2.1.2.3.2 in 3GPP2 C.S0002-A v6.0:
 * "Physical Layer Standard for cdma2000 Spread Spectrum Systems", page 2-49,
 * line 16~30.
 * @lTotalDelta: From spec, power level is using 0.125dbm as unit, to avoid
 * float type format, setting this variable to 8 times for calculated power.
 * lTotalDelta>0, means power overriding; <0, means to raise rate
 * @sRatePowerGainFch: (delta(Nominal_Attribute_Gain) +
 * delta(Attribute_Adjustment_Gain)) on R-FCH
 * @sRatePowerGainSch: (delta(Nominal_Attribute_Gain) +
 * delta(Attribute_Adjustment_Gain)) on R-SCH
 * @usEstimatedChannelMask: after SDR has finished to calculate the estimated
 * power on existed channels, set related bit masks to 1. MAC will follow it
 * to adjust data rate on related channel.
 * @lEstimatedPilotPower: estimated pilot power. From spec, power level is
 * using 0.125dbm as unit, to avoid float type format, setting this variable
 * to 8 times for calculated power. And variables below use the same way to
 * enlarge 8 times.
 * @lEstimatedFchPower: estimated R-FCH power
 * @lEstimatedSchPower: estimated R-SCH power
 * @lEstimatedDcchPower: estimated R-DCCH power
 * @lEstimatedScchPower: estimated R-SCCH power
 * @ausReserve2: reserve for future
 * @usNomRevCommChAttGain: "Nominal_Reverse_Common_Channel_Attribute_Gain", which is  the
 * relative header gain for the Enhanced Access Channel Header, and the relative data gain
 * for the Enhanced Access Channel Data and Reverse Common Channel Data for each data
 * rate and frame duration supported by the mobile station.
 *******************************************************************************/
typedef struct
{
    VOS_INT32                           lTotalDelta;
    VOS_INT16                           sRatePowerGainFch;
    VOS_INT16                           sRatePowerGainSch;
    VOS_UINT16                          usEstimatedChannelMask;
    VOS_UINT16                          ausReserve1[1];
    VOS_INT32                           lEstimatedPilotPower;
    VOS_INT32                           lEstimatedFchPower;
    VOS_INT32                           lEstimatedSchPower;
    VOS_INT32                           lEstimatedDcchPower;
    VOS_INT32                           lEstimatedScchPower;
    VOS_UINT16                          ausReserve2[3];
    VOS_UINT16                          usNomRevCommChAttGain;
}CTTF_CSDR_1X_R_POWERCTRL_STRU;

/** ****************************************************************************
 * Name        : CTTF_CSDR_1X_ACH_DATA_REQ_STRU
 * Description :
 * @enMutexFlag:
 * -  at 10ms before boundary, MAC writes data into share memory, after that
 *    sets enMutexFlag into with data.
 * -  MAC should both write preamble parameter and data, after then set it to
 *    data existed
 * -  SDR read out data, and then sets it into without data.
 * @usRa: access channel number
 * @usPwrLvl: power level adjustment of the Access probe, in units of
 * PWR_STEPs, sent in the PHY-ACHPreamble.Request primitive and
 * PHY-ACH.Request  primitive;
 * @usRn: the pseudo-random offset of the Access probe from a zero-offset
 * Access Channel frame.
 * @usNumPreambleFrames: the number of Access Channel preamble frames, sent in
 * the PHY-ACHPreamble.Request primitive
 * @usDataNum: number of ACH frames in a probe
 * @usBlkBitSize: a frame(block) bit size
 * @usBaseId: Base station identification
 * @aulDataAddr: contains every ACH data block start addresses
 * @ausReserve2: reserve for future
 *******************************************************************************/
typedef struct
{
    CSDR_1X_MUTEX_ENUM_UINT16           enMutexFlag;
    VOS_UINT16                          usRa;
    VOS_UINT16                          usPwrLvl;
    VOS_UINT16                          usRn;
    VOS_UINT16                          usNumPreambleFrames;
    VOS_UINT16                          usDataNum;
    VOS_UINT16                          usBlkBitSize;
    VOS_UINT16                          usBaseId;
    VOS_UINT32                          aulDataAddr[CSDR_1X_MAX_ACH_DATA_BLK_CNT];
    VOS_UINT16                          ausReserve2[4];
}CTTF_CSDR_1X_ACH_DATA_REQ_STRU;

/** ****************************************************************************
 * Name        : CTTF_CSDR_1X_DCCH_DATA_REQ_STRU
 * Description :
 * Included parameters are defined in section 2.2.1.1.1.7.2 in 3GPP2 C.S0003-A
 * v6.0: "Medium Access Control (MAC) Standard for cdma2000 Spread Spectrum
 * Systems".
 * Use share memory to imply this signal, the structure looks like below:
 * @enMutexFlag:
 * -  at 10ms before boundary, MAC writes data into share memory, after that
 *    sets enMutexFlag into with data.
 * -  SDR read out data, and then sets it into without data.
 * @enFrameDuration:  The duration of the frame
 * @usBlkBitSize: a frame(block) bit size
 * @ulDataAddr: data block start address
 * @ausReserve1: reserve for future
 *******************************************************************************/
typedef struct
{
    CSDR_1X_FRAME_DURATION_ENUM_UINT16  enFrameDuration;
    VOS_UINT16                          usBlkBitSize;
    VOS_UINT16                          usTimeStampNumOf80ms;                   /* 80ms的倍数，5.12周期为0~63，2s周期为0~24 */
    VOS_UINT16                          usTimeStampNumOf1p25ms;                 /* 1.25ms的倍数，0~63 */
    CTTF_CSDR_1X_R_TCH_ADJ_GAIN_STRU    stDcchPcAdjGain;
    VOS_UINT32                          ulDataAddr;
    VOS_UINT16                          ausReserve1[4];
}CTTF_CSDR_1X_R_DCCH_DATA_INFO_STRU;

/** ****************************************************************************
 * Name        : CTTF_CSDR_1X_EACH_DATA_REQ_STRU
 * Description :
 * Now EACH only support basic mode, and using share memory to imply it.
 * Preamble and data are together.
 * @enMutexFlag:
 * -  at 10ms before boundary, MAC writes data into share memory, after that
 *    sets enMutexFlag into with data.
 * -  MAC should both write preamble parameter and data, after then set it to
 *    data existed
 * -  SDR read out data, and then sets it into without data.
 * @usPwrLvl: the power level adjustment of the Enhanced Access probe, in
 * units of EACH_PWR_STEPs, sent in the PHY-EACHPreamble.Request primitive,
 * the PHY-EACHHeader.Request primitive, and the PHY-EACH.Request primitive.
 * @usFccchId: Forward Common Control Channel number
 * @usBaseId: Base station identification
 * @enFrameDuration:  The duration of the frame
 * @usDelaySlot: as EACH slot could be quite short, even 1.25ms, MAC is hard
 * to handle that order of magnitudes. So MAC gather all slots need to delay,
 * and asks SDR to do the delay before sending preamble.
 * @usIndex: the index of MODE PARM REC array in Enhanced Access Parameters
 * Message, [0..7]. It's used to match the array, to make sure that PHY and
 * MAC will use the parameters from the same occurrence.
 * @usBlkBitSize: a frame(block) bit size
 * @usDataNum: number of ACH frames in a probe
 * @aulDataAddr: it contains every ACH data block start addresses
 * @ausReserve2: reserve for future
 *******************************************************************************/
typedef struct
{
    CSDR_1X_MUTEX_ENUM_UINT16           enMutexFlag;
    VOS_UINT16                          usPwrLvl;
    VOS_UINT16                          usFccchId;
    VOS_UINT16                          usEachId;
    VOS_UINT16                          usBaseId;
    CSDR_1X_FRAME_DURATION_ENUM_UINT16  enFrameDuration;
    VOS_UINT16                          usDelaySlot;
    VOS_UINT16                          usIndex;
    VOS_UINT16                          usBlkBitSize;
    VOS_UINT16                          usDataNum;
    VOS_UINT32                          aulDataAddr[CSDR_1X_MAX_EACH_DATA_BLK_CNT];
    VOS_UINT16                          ausReserve2[4];
}CTTF_CSDR_1X_EACH_DATA_REQ_STRU;

/** ****************************************************************************
 * Name        : CTTF_CSDR_1X_R_FCH_DATA_INFO_STRU
 * Description :
 * Included parameters are defined in section 2.2.1.1.1.7.1 in 3GPP2 C.S0003-A
 * v6.0: "Medium Access Control (MAC) Standard for cdma2000 Spread Spectrum
 * Systems".
 * Use share memory to imply this signal, the structure looks like below:
 * @enMutexFlag:
 * -  at 10ms before boundary, MAC writes data into share memory, after that
 *    sets enMutexFlag into with data.
 * -  SDR read out data, and then sets it into without data.
 * @enFrameDuration:  The duration of the frame
 * @usBlkBitSize: a frame(block) bit size
 * @ulDataAddr: data block start address
 * @ausReserve1: reserve for future
 *******************************************************************************/
typedef struct
{
    CSDR_1X_FRAME_DURATION_ENUM_UINT16  enFrameDuration;
    VOS_UINT16                          usBlkBitSize;
    VOS_UINT16                          usTimeStampNumOf80ms;                   /* 80ms的倍数，5.12周期为0~63，2s周期为0~24 */
    VOS_UINT16                          usTimeStampNumOf1p25ms;                 /* 1.25ms的倍数，0~63 */
    CTTF_CSDR_1X_R_TCH_ADJ_GAIN_STRU    stFchAdjGain;
    VOS_UINT32                          ulDataAddr;
    VOS_UINT16                          ausReserve1[4];

}CTTF_CSDR_1X_R_FCH_DATA_INFO_STRU;

/** ****************************************************************************
 * Name        : CTTF_CSDR_1X_R_CTRL_HEADER_STRU
 * Description : It's general control for channel management. It's on top of
 * all channels data management. After that, it's per channel data management
 * one by one.
 * @usAllowedTx: To control whether L2 can tx any data or not. If not allow,
 * it means L2 can not tx any channel data. If allow, L2 can tx data on
 * channel that its channel-id matches L2 maintained channel-id.
 * @usAchCfgId, @usEachCfgId, @RFchCfgId, @RDcchCfgId, @RSchCfgId, @RScchCfgId:
 * -  SDR uses cfg-id in new configuration to update corresponding channel
 *    cfg-id in memory, it should be done between the last data on the old cfg
 *    and 10ms before the modulation boundary, SDRC writes the new ConfigID to
 *    the shared memory.
 * -  When a configuration change is pending, MAC shall read the ConfigID
 *    before gathering the data. If cfg-id in memory and cfg-id stored in MAC
 *    are different, which means the ConfigID has changed, MAC shall perform
 *    the config change.
 * -  When SDR release a channel, it should set cfg-id corresponding in memory
 *    into NO_CHANNEL_CFG_ID, which is 0xFFFF.
 *******************************************************************************/
typedef struct
{
    CSDR_1X_TX_CTRL_ENUM_UINT16         enAllowedTx;
    VOS_UINT16                          usAchCfgId;
    VOS_UINT16                          usEachCfgId;
    VOS_UINT16                          usRFchCfgId;
    VOS_UINT16                          usRDcchCfgId;
    VOS_UINT16                          usRSchCfgId;
    VOS_UINT16                          usRScchCfgId;
    VOS_UINT16                          ausReserve[1];
}CTTF_CSDR_1X_R_CTRL_HEADER_STRU;

/** ****************************************************************************
 * Name        : CTTF_CSDR_1X_R_DATA_BUFFER_STRU
 * Description : It's used to corporate with per channel data management to
 * indicate where and how many bits need to transmit on certain type channel.
 * And also with some parameters about this channel.
 *******************************************************************************/
typedef struct
{
    VOS_UINT16                          ausAchProbeData[CSDR_1X_MAX_ACH_DATA_BLK_CNT][CSDR_1X_ACH_PER_PROBE_BLK_MAX_SIZE];
    VOS_UINT16                          ausEachProbeData[CSDR_1X_MAX_EACH_DATA_BLK_CNT][CSDR_1X_EACH_PER_PROBE_BLK_MAX_SIZE];
    VOS_UINT16                          ausFchData[CSDR_1X_REV_MAX_BLK_NUM_PER_RING_BUFFER][CSDR_1X_RFCH_BLK_MAX_SIZE];
    VOS_UINT16                          ausSchData[CSDR_1X_REV_MAX_BLK_NUM_PER_RING_BUFFER][CSDR_1X_RSCH_BLK_MAX_SIZE];
    VOS_UINT16                          ausDcchData[CSDR_1X_REV_MAX_BLK_NUM_PER_RING_BUFFER][CSDR_1X_RDCCH_BLK_MAX_SIZE];
    VOS_UINT16                          ausScchData[CSDR_1X_REV_MAX_BLK_NUM_PER_RING_BUFFER][CSDR_1X_RSCCH_BLK_MAX_SIZE];
}CTTF_CSDR_1X_R_DATA_BUFFER_STRU;

/** ****************************************************************************
 * Name        : CTTF_CSDR_1X_R_SCCH_DATA_INFO_STRU
 * Description :
 * Included parameters are defined in section 2.2.1.1.1.7.3 in 3GPP2 C.S0003-A
 * v6.0: "Medium Access Control (MAC) Standard for cdma2000 Spread Spectrum
 * Systems".
 * Now SCCH has designed in RTT(includes HW and L1) only for chip testing, the
 * product does not need it. So just give an interface between L1 and L2. But
 * L2 will not try to implements SCCH. And L1 and L2 agree to use share memory
 * to imply this signal, the structure looks like below temporarily:
 * @enMutexFlag:
 * -  at 10ms before boundary, MAC writes data into share memory, after that
 *    sets enMutexFlag into with data.
 * -  SDR read out data, and then sets it into without data.
 * @enFrameDuration:  The duration of the frame
 * @usBlkBitSize: a frame(block) bit size
 * @ulDataAddr: data block start address
 * @ausReserve1: reserve for future
 *******************************************************************************/
typedef struct
{
    CSDR_1X_FRAME_DURATION_ENUM_UINT16  enFrameDuration;
    VOS_UINT16                          usBlkBitSize;
    VOS_UINT16                          usTimeStampNumOf80ms;                   /* 80ms的倍数，5.12周期为0~63，2s周期为0~24 */
    VOS_UINT16                          usTimeStampNumOf1p25ms;                 /* 1.25ms的倍数，0~63 */
    VOS_UINT32                          ulDataAddr;
    VOS_UINT16                          ausReserve1[4];
}CTTF_CSDR_1X_R_SCCH_DATA_INFO_STRU;

/** ****************************************************************************
 * Name        : CTTF_CSDR_1X_R_SCH_DATA_INFO_STRU
 * Description :
 * Included parameters are defined in section 2.2.1.1.1.7.4 in 3GPP2 C.S0003-A
 * v6.0: "Medium Access Control (MAC) Standard for cdma2000 Spread Spectrum
 * Systems".
 * Now only support one SCH, and use share memory to imply this signal, the
 * structure looks like below:
 * @enMutexFlag:
 * -  at 10ms before boundary, MAC writes data into share memory, after that
 *    sets enMutexFlag into with data.
 * -  SDR read out data, and then sets it into without data.
 * @enFrameDuration:  The duration of the frame
 * @usBlkBitSize: a frame(block) bit size
 * @pulData: data block start address
 * @ausReserve1: reserve for future
 *******************************************************************************/
typedef struct
{
    CSDR_1X_FRAME_DURATION_ENUM_UINT16  enFrameDuration;
    VOS_UINT16                          usBlkBitSize;
    VOS_UINT16                          usTimeStampNumOf80ms;                   /* 80ms的倍数，5.12周期为0~63，2s周期为0~24 */
    VOS_UINT16                          usTimeStampNumOf1p25ms;                 /* 1.25ms的倍数，0~63 */
    CTTF_CSDR_1X_R_TCH_ADJ_GAIN_STRU    stSchAdjGain;
    VOS_UINT32                          ulDataAddr;
    VOS_UINT16                          ausReserve1[4];
}CTTF_CSDR_1X_R_SCH_DATA_INFO_STRU;

/** ****************************************************************************
 * Name        : CTTF_CSDR_1X_FCH_DATA_REQ_STRU
 * Description : MAC use head index, PHY use tail index
 *******************************************************************************/
typedef struct
{
    VOS_UINT16                          usHeadIdx;                                          /**<  MAC use head index */
    VOS_UINT16                          usTailIdx;                                          /**<  PHY use tail index */
    CTTF_CSDR_1X_R_FCH_DATA_INFO_STRU   ast1xDataInfo[CSDR_1X_REV_MAX_BLK_NUM_PER_RING_BUFFER];
}CTTF_CSDR_1X_FCH_DATA_REQ_STRU;

/** ****************************************************************************
 * Name        : CTTF_CSDR_1X_SCH_DATA_REQ_STRU
 * Description : MAC use head index, PHY use tail index
 *******************************************************************************/
typedef struct
{
    VOS_UINT16                          usHeadIdx;                                          /**<  MAC use head index */
    VOS_UINT16                          usTailIdx;                                          /**<  PHY use tail index */
    CTTF_CSDR_1X_R_SCH_DATA_INFO_STRU   ast1xDataInfo[CSDR_1X_REV_MAX_BLK_NUM_PER_RING_BUFFER];
}CTTF_CSDR_1X_SCH_DATA_REQ_STRU;

/** ****************************************************************************
 * Name        : CTTF_CSDR_1X_DCCH_DATA_REQ_STRU
 * Description : MAC use head index, PHY use tail index
 *******************************************************************************/
typedef struct
{
    VOS_UINT16                          usHeadIdx;                                          /**<  MAC use head index */
    VOS_UINT16                          usTailIdx;                                          /**<  PHY use tail index */
    CTTF_CSDR_1X_R_DCCH_DATA_INFO_STRU  ast1xDataInfo[CSDR_1X_REV_MAX_BLK_NUM_PER_RING_BUFFER];
}CTTF_CSDR_1X_DCCH_DATA_REQ_STRU;

/** ****************************************************************************
 * Name        : CTTF_CSDR_1X_SCCH_DATA_REQ_STRU
 * Description : MAC use head index, PHY use tail index
 *******************************************************************************/
typedef struct
{
    VOS_UINT16                          usHeadIdx;                                          /**<  MAC use head index */
    VOS_UINT16                          usTailIdx;                                          /**<  PHY use tail index */
    CTTF_CSDR_1X_R_SCCH_DATA_INFO_STRU  ast1xDataInfo[CSDR_1X_REV_MAX_BLK_NUM_PER_RING_BUFFER];
}CTTF_CSDR_1X_SCCH_DATA_REQ_STRU;

/** ****************************************************************************
 * Name        : CTTF_CSDR_1X_R_CTRL_MGMT_STRU
 * Description : It's channel data management, shared in memory between
 * 1x_Layer_1 and 1x_MAC_Tx. After CTTF_CSDR_1X_R_CTRL_HEADER_STRU, it is per
 * channel data management one by one. The order is ACH, EACH, FCH, SCH, DCCH
 * and SCCH. See more detail in CTTF_CSDR_1X_ACH_DATA_REQ_STRU,
 * CTTF_CSDR_1X_EACH_DATA_REQ_STRU, CTTF_CSDR_1X_FCH_DATA_REQ_STRU,
 * CTTF_CSDR_1X_SCH_DATA_REQ_STRU, CTTF_CSDR_1X_DCCH_DATA_REQ_STRU and
 * CTTF_CSDR_1X_SCCH_DATA_REQ_STRU.
 * It's stored in SDR TCM non-power-down area.
 * When power-on or RAT turns back to CDMA, SDR will initial this structure
 * and link data pointers.
 * When release channels, MAC need to set tail index to head index.
 *******************************************************************************/
typedef struct
{
    CTTF_CSDR_1X_R_CTRL_HEADER_STRU     st1xCtrlHeader;
    CTTF_CSDR_1X_R_POWERCTRL_STRU       st1xPowerCtrl;
    CTTF_CSDR_1X_ACH_DATA_REQ_STRU      st1xAchData;
    CTTF_CSDR_1X_EACH_DATA_REQ_STRU     st1xEachData;
    CTTF_CSDR_1X_FCH_DATA_REQ_STRU      st1xFchData;
    CTTF_CSDR_1X_SCH_DATA_REQ_STRU      st1xSchData;
    CTTF_CSDR_1X_DCCH_DATA_REQ_STRU     st1xDcchData;
    CTTF_CSDR_1X_SCCH_DATA_REQ_STRU     st1xScchData;
}CTTF_CSDR_1X_R_CTRL_MGMT_STRU;


/*******************************************************************************
 7. OTHER declarations
*******************************************************************************/
/** ****************************************************************************
 * Name        : CTTF_CSDR_1X_ACH_TRACE_DATA_REQ_STRU
 * Description :
 * This signal is used to trace PHY-ACHPreamble.Request and PHY-ACH.Request.
 * @usBlkBitSize shows how many bit is used in every block in the same probe,
 * using it to calculate how many octet will be occupied.
 *******************************************************************************/
typedef struct
{
    VOS_MSG_HEADER                                                               /* _H2ASN_Skip */
    CSDR_1X_ENCDATA_PIF_MSG_TYPE_ENUM_UINT16                enMsgId;             /* _H2ASN_Skip */
    VOS_UINT16                                              usOpId;
    CSDR_1X_MUTEX_ENUM_UINT16                               enMutexFlag;
    VOS_UINT16                                              usCfgId;
    VOS_UINT16                                              usRa;
    VOS_UINT16                                              usPwrLvl;
    VOS_UINT16                                              usRn;
    VOS_UINT16                                              usNumPreambleFrames;
    VOS_UINT16                                              usDataNum;
    VOS_UINT16                                              usBlkBitSize;
    VOS_UINT16                                              usBaseId;
    VOS_UINT16                                              ausReserve1[1];
    VOS_UINT8                                               aucData[CSDR_1X_MAX_ACH_DATA_BLK_CNT][CSDR_1X_ACH_PER_PROBE_BLK_MAX_MEM_OCCUPIED];
}CTTF_CSDR_1X_ACH_TRACE_DATA_REQ_STRU;

/** ****************************************************************************
 * Name        : CTTF_CSDR_1X_DCCH_TRACE_DATA_REQ_STRU
 * Description :
 * This signal is used to trace PHY-DCCH.Request, including parameters are
 * defined in section 2.2.1.1.1.7.2 in 3GPP2 C.S0003-A v6.0: "Medium Access
 * Control (MAC) Standard for cdma2000 Spread Spectrum Systems". @usBlkBitSize
 * shows how many bit is used in every block in current frame, using it to
 * calculate how many octet will be occupied.
 *******************************************************************************/
typedef struct
{
    VOS_MSG_HEADER                                                           /* _H2ASN_Skip */
    CSDR_1X_ENCDATA_PIF_MSG_TYPE_ENUM_UINT16                enMsgId;         /* _H2ASN_Skip */
    VOS_UINT16                                              usOpId;
    CSDR_1X_MUTEX_ENUM_UINT16                               enMutexFlag;
    VOS_UINT16                                              usCfgId;
    CSDR_1X_FRAME_DURATION_ENUM_UINT16                      enFrameDuration;
    VOS_UINT16                                              usBlkBitSize;
    VOS_UINT8                                               aucData[CSDR_1X_RDCCH_BLK_MAX_MEM_OCCUPIED];
}CTTF_CSDR_1X_DCCH_TRACE_DATA_REQ_STRU;

/** ****************************************************************************
 * Name        : CTTF_CSDR_1X_EACH_TRACE_DATA_REQ_STRU
 * Description :
 * This signal is used to trace PHY-EACHPreamble.Request and PHY-EACH.Request.
 * @usBlkBitSize shows how many bit is used in every block in the same probe,
 * using it to calculate how many octet will be occupied.
 *******************************************************************************/
typedef struct
{
    VOS_MSG_HEADER                                                           /* _H2ASN_Skip */
    CSDR_1X_ENCDATA_PIF_MSG_TYPE_ENUM_UINT16                enMsgId;         /* _H2ASN_Skip */
    VOS_UINT16                                              usOpId;
    CSDR_1X_MUTEX_ENUM_UINT16                               enMutexFlag;
    VOS_UINT16                                              usCfgId;
    VOS_UINT16                                              usPwrLvl;
    VOS_UINT16                                              usFccchId;
    VOS_UINT16                                              usEachId;
    VOS_UINT16                                              usBaseId;
    CSDR_1X_FRAME_DURATION_ENUM_UINT16                      enFrameDuration;
    VOS_UINT16                                              usDelaySlot;
    VOS_UINT16                                              usIndex;
    VOS_UINT16                                              usBlkBitSize;
    VOS_UINT16                                              usDataNum;
    VOS_UINT16                                              ausReserve1[1];
    VOS_UINT8                                               aucData[CSDR_1X_MAX_EACH_DATA_BLK_CNT][CSDR_1X_EACH_PER_PROBE_BLK_MAX_MEM_OCCUPIED];
}CTTF_CSDR_1X_EACH_TRACE_DATA_REQ_STRU;

/** ****************************************************************************
 * Name        : CTTF_CSDR_1X_FCH_TRACE_DATA_REQ_STRU
 * Description :
 * This signal is used to trace PHY-FCH.Request, including parameters are
 * defined in section 2.2.1.1.1.7.1 in 3GPP2 C.S0003-A v6.0: "Medium Access
 * Control (MAC) Standard for cdma2000 Spread Spectrum Systems". @usBlkBitSize
 * shows how many bit is used in every block in current frame, using it to
 * calculate how many octet will be occupied.
 *******************************************************************************/
typedef struct
{
    VOS_MSG_HEADER                                                           /* _H2ASN_Skip */
    CSDR_1X_ENCDATA_PIF_MSG_TYPE_ENUM_UINT16                enMsgId;         /* _H2ASN_Skip */
    VOS_UINT16                                              usOpId;
    CSDR_1X_MUTEX_ENUM_UINT16                               enMutexFlag;
    VOS_UINT16                                              usCfgId;
    CSDR_1X_FRAME_DURATION_ENUM_UINT16                      enFrameDuration;
    VOS_UINT16                                              usBlkBitSize;
    VOS_UINT8                                               aucData[CSDR_1X_RFCH_BLK_MAX_MEM_OCCUPIED];
    VOS_UINT16                                              ausReserve[4];
}CTTF_CSDR_1X_FCH_TRACE_DATA_REQ_STRU;

/** ****************************************************************************
 * Name        : CTTF_CSDR_1X_SCCH_TRACE_DATA_REQ_STRU
 * Description :
 * This signal is used to trace PHY-SCCH.Request, including parameters are
 * defined in section 2.2.1.1.1.7.3 in 3GPP2 C.S0003-A v6.0: "Medium Access
 * Control (MAC) Standard for cdma2000 Spread Spectrum Systems". Now not
 * support SCCH.
 *******************************************************************************/
typedef struct
{
    VOS_MSG_HEADER                                                   /* _H2ASN_Skip */
    CSDR_1X_ENCDATA_PIF_MSG_TYPE_ENUM_UINT16                enMsgId; /* _H2ASN_Skip */
    VOS_UINT16                                              usOpId;
}CTTF_CSDR_1X_SCCH_TRACE_DATA_REQ_STRU;

/** ****************************************************************************
 * Name        : CTTF_CSDR_1X_SCH_TRACE_DATA_REQ_STRU
 * Description :
 * This signal is used to trace PHY-SCH.Request, including parameters are
 * defined in section 2.2.1.1.1.7.4 in 3GPP2 C.S0003-A v6.0: "Medium Access
 * Control (MAC) Standard for cdma2000 Spread Spectrum Systems". @usBlkBitSize
 * shows how many bit is used in every block in current frame, using it to
 * calculate how many octet will be occupied.
 *******************************************************************************/
typedef struct
{
    VOS_MSG_HEADER                                                           /* _H2ASN_Skip */
    CSDR_1X_ENCDATA_PIF_MSG_TYPE_ENUM_UINT16                enMsgId;         /* _H2ASN_Skip */
    VOS_UINT16                                              usOpId;
    CSDR_1X_MUTEX_ENUM_UINT16                               enMutexFlag;
    VOS_UINT16                                              usCfgId;
    CSDR_1X_FRAME_DURATION_ENUM_UINT16                      enFrameDuration;
    VOS_UINT16                                              usBlkBitSize;
    VOS_UINT8                                               aucData[CSDR_1X_RSCH_BLK_MAX_MEM_OCCUPIED];
    VOS_UINT16                                              ausReserve[4];
}CTTF_CSDR_1X_SCH_TRACE_DATA_REQ_STRU;


/*******************************************************************************
 8. Global  declaration
*******************************************************************************/

/*******************************************************************************
 9. Function declarations
*******************************************************************************/
/** ****************************************************************************
 * Name        : CSDR_1x_EncData_PIF_MSG_DATA
 * Description : H2ASN top level message structure definition
 *******************************************************************************/
typedef struct
{
    CSDR_1X_ENCDATA_PIF_MSG_TYPE_ENUM_UINT16                enMsgId;     /* _H2ASN_MsgChoice_Export CSDR_1X_ENCDATA_PIF_MSG_TYPE_ENUM_UINT16 */
    VOS_UINT8                                               aucMsgBlock[2];

    /* _H2ASN_MsgChoice_When_Comment CSDR_1X_ENCDATA_PIF_MSG_TYPE_ENUM_UINT16 */
}CSDR_1x_EncData_PIF_MSG_DATA;

/* _H2ASN_Length UINT32*/
/** ****************************************************************************
 * Name        : CSDR_1x_EncData_PIF
 * Description : H2ASN top level message structure definition
 *******************************************************************************/
typedef struct
{
    VOS_MSG_HEADER
    CSDR_1x_EncData_PIF_MSG_DATA        stMsgData;
}CSDR_1x_EncData_PIF;


#if ((VOS_OS_VER == VOS_WIN32) || (VOS_OS_VER == VOS_NUCLEUS))
#pragma pack()
#else
#pragma pack(0)
#endif

#ifdef __cplusplus
#if __cplusplus
}
#endif /* __cpluscplus */
#endif /* __cpluscplus */

#endif
